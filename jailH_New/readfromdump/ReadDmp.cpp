/*
 * Module for reading .dump file generated by python script
 *
 *  Author :
 *
 *  Copyright (C) 2017 , All Rights Reserved.
 */

#include "ReadDmp.h"
#include "../J_error.h"
#include "cell_type_util.h"
#include <sstream>
#include <string>
#include <fstream>
#include <typeinfo>
#include <iostream>
ReadDmp::ReadDmp(std::string info_file, std::string dump_file)
{
  try
  {
    get_config_info(info_file);
    get_dumped_obj(dump_file);
    if(root)
      add_jailhouse_system();
    else
      add_jailhouse_cell_desc();
    add_cpus();
    add_jailhouse_memory();
    add_jailhouse_irqchip();
    add_jailhouse_pci_device();
  }
  catch (std::exception & e)
  {
    std::cout << "std::excp"<< e.what() <<'\n';
    throw;
  }
}

void ReadDmp::get_config_info(std::string & info_file)
{
  std::string name = info_file;
  std::ifstream infile(name.c_str());
  if( ! infile.good() )
  {
    std::string error_msg = "file notpresent" + name;
    throw ReadDmp_error(error_msg.c_str());
  }
  std::string line;
  int i = 0;
  while (std::getline(infile, line))
  {
    std::istringstream iss(line);
    int  b;
    std::string a;
    if (!(iss >> a >> b)) { break; } // error
    if( a == "revision")
    {
      if( b != JAILHOUSE_CONFIG_REVISION )
      {
        std::string error_msg = "file" + name + " is of revision "
          + std::to_string(b) + " but the current revision of"
          " of config in applicaiton is " 
          + std::to_string( JAILHOUSE_CONFIG_REVISION);
        throw ReadDmp_error(error_msg.c_str());
      }
    }
    else if(a == "root")
      if( b == 1)
        root = true;
      else
        root = false;
    else if( a == "cpu_count")
      cpu_count = b;
    else if( a == "mem_count")
      mem_count = b;
    else if( a == "irq_count")
      irq_count = b;
    else if( a == "pci_count")
      pci_count = b;
    else
    {
      std::string error_msg = "file" + name + 
        " content not proper";
      throw ReadDmp_error(error_msg.c_str());
    }
    ++i;
  }
  //Hari 
  // Can we make this "5" below as a function. It should return 5 for this version of the ConfigFile
  // We should make this as a function of ".revision = JAILHOUSE_CONFIG_REVISION".
  // You man need to get the VERSION in the .info file as well to get it to this code.
  // This could help us future proof this code.
  // ---------- VERSION will be included in the .info file
  // but below "5" is the number of rows in the ".info" file
  // it has nothing to do with version -- DONE
  
  if( i != 6 )   // indicate the number of rows in .info
  {
    std::string error_msg = "file" + name + 
                    " content not proper";
    throw ReadDmp_error(error_msg.c_str());
  }
}

void ReadDmp::get_dumped_obj(std::string & dump_file)
{
  FILE *pFile;
  long lSize;
  size_t result;
  std::string name= dump_file ;
  pFile=fopen( name.c_str(),"rb");
  if( ! pFile)
  {
    std::string error_msg = "file notpresent" + name;
    throw ReadDmp_error(error_msg.c_str());
  }
  fseek (pFile , 0 , SEEK_END);
  lSize = ftell (pFile);
  rewind (pFile);
  p_buffer = (char*) malloc (sizeof(char)*lSize);
  dmp_buffer = p_buffer;
  if (p_buffer == NULL) 
  {
    fputs ("Memory error",stderr); 
  }
  // copy the file into the buffer:
  result = fread (p_buffer,1,lSize,pFile);
  if(result == 0 ) //error
  {
    // Hari
    // memory leak - should we consider freeing p_buffer here?
    // DONE it is freed in distructor
    std::string error_msg = "file " + name + "empty";
    throw ReadDmp_error(error_msg.c_str());
  }
  fclose (pFile);
}

void  ReadDmp::add_jailhouse_cell_desc()
{
  struct jailhouse_cell_desc * cell_desc;
  cell_desc = (jailhouse_cell_desc*) malloc(sizeof(jailhouse_cell_desc));
  memcpy(cell_desc,p_buffer,sizeof(jailhouse_cell_desc));
  ( p_buffer) =(p_buffer) + sizeof(jailhouse_cell_desc);

  cell_name = cell_desc->name;
  int vpci_irq_base = cell_desc->vpci_irq_base;
  std::string signature = cell_desc->signature;
  __u16 revision = cell_desc->revision;
  //__u64 flags = cell_desc->flags;
  auto flags = get_cell_desc_flags(cell_desc->flags);
  auto nrcell = new JailHouseCell(cell_name);
  nrcell->set_signature(signature.substr(0,sizeof(cell_desc->signature)));
  nrcell->set_revision(get_revision(revision));
  nrcell->set_vpci_irq_base(vpci_irq_base);
  nrcell->set_flags(flags);
  cell = nrcell;
  free(cell_desc);
}

//Hari
// Should we rename this fucntion name to ReadDmp::add_jailhouse_system_and_root_cell() ?
// ----------- jailhouse_system is present only for root cell 
// and all the cell info is inside the jailhouse system
void  ReadDmp::add_jailhouse_system()
{
  struct jailhouse_system * header;
  header =(jailhouse_system*) malloc(sizeof(jailhouse_system));
  memcpy(header,p_buffer,sizeof(jailhouse_system));
  ( p_buffer) =(p_buffer) + sizeof(jailhouse_system);
  
  cell_name = (header->root_cell).name;
  int vpci_irq_base = (header->root_cell).vpci_irq_base;
  std::string signature = header->signature;
  __u16 revision = header->revision;
  auto rcell = new RootCell(cell_name);
  auto hm = get_Hypervisor_Memory(header);
  auto dc = get_Debug_Console(header);
  auto pi = get_Platform_Info(header);
  rcell->set_Hypervisor_Memory(hm);
  rcell->set_Debug_Console(dc);
  rcell->set_Platform_Info(pi);
  rcell->set_signature(signature.substr(0,sizeof(header->signature)));
  rcell->set_revision(get_revision(revision));
  rcell->set_vpci_irq_base(vpci_irq_base);
  cell = rcell;
  free(header);
}

Hypervisor_Memory ReadDmp::get_Hypervisor_Memory(
                      const jailhouse_system * p_js)
{
  Hypervisor_Memory hm;
  hm.phys_start = (p_js->hypervisor_memory).phys_start;
  hm.size = (p_js->hypervisor_memory).size;
  return hm;
}

Debug_Console  ReadDmp::get_Debug_Console(
                  const jailhouse_system * p_js)
{
  Debug_Console dc;
  dc.address = (p_js->debug_console).address;
  dc.size = (p_js->debug_console).size;
  auto ret = get_debug_console_flags((p_js->debug_console).flags,
      dc.address);
  dc.flags  = ret;
  // Hari - we seem to be returning the contents of the stack varibale dc - is ok?
  // Would it work at all times?
  // --------- it will, if there is some kind of problem pls mention.
  return dc;
}

Platform_Info  ReadDmp::get_Platform_Info(
                  const jailhouse_system * p_js)
{
  Platform_Info pi;
  pi.pci_mmconfig_base = (__u64)(p_js->platform_info).pci_mmconfig_base;
  pi.pci_mmconfig_end_bus = (__u8)(p_js->platform_info).pci_mmconfig_end_bus;
  pi.pci_is_virtual = (__u8)(p_js->platform_info).pci_is_virtual;
  //pi.gic_version  = (p_js->platform_info).arm.gic_version;
  pi.gicd_base = (__u64)(p_js->platform_info).arm.gicd_base;
  pi.gicc_base = (__u64)(p_js->platform_info).arm.gicc_base;
  pi.gich_base = (__u64)(p_js->platform_info).arm.gich_base;
  pi.gicv_base = (__u64)(p_js->platform_info).arm.gicv_base;
  pi.maintenance_irq =(__u8) (p_js->platform_info).arm.maintenance_irq;
  return pi;
}

void  ReadDmp::add_cpus()
{
  //read cpus
  __u64 cpu_val;
  //Hari
  // Suggestion - Instead of mallocing a sizeof(__u64) and freeing it later (causing fragmentation),
  // Would it be easier to allocation a local __u64 varibale and have __u64 *cpu point to the same?
  // ------------- we can do it-DONE
  //__u64 *cpu;
  //cpu =(__u64*) malloc(sizeof(__u64));
  for(int i = 0; i < cpu_count ; ++i)
  {
    memcpy(&cpu_val,p_buffer,sizeof(__u64));
    //memcpy(cpu,p_buffer,sizeof(__u64));
    p_buffer =(p_buffer) + sizeof(__u64);
    //printf("cpu[%d] = %04x \n ", i+1, *cpu);
    //auto cpu_val = *cpu;
    
    //Hari - We seem to be hard coding 6 CPUs here - Should we instead use cpu_count?
    //-------- below 6 total number of cpus , we can define it in a macro
    //and in config structure, size of __u64 array cpus[] will always be one, 
    //so cpu_count is always one 
    std::vector<bool> cpu_vec(NUMBER_OF_CPU);
    for(int i = 0 ; i < NUMBER_OF_CPU ; ++i)
    {
      if( cpu_val & (1 << i ))
        cpu_vec[i] = true;
      else
        cpu_vec[i] = false;
    }
    cell->set_cpuIds(cpu_vec);
  }
  //free(cpu);
}

void  ReadDmp::add_jailhouse_memory()
{
  struct jailhouse_memory * mem_reg;
  mem_reg =(jailhouse_memory*) malloc(sizeof(jailhouse_memory));
  for(int i=0; i < mem_count ; ++i )
  {
    memcpy(mem_reg,p_buffer,sizeof(jailhouse_memory));
    p_buffer = (p_buffer) + sizeof(jailhouse_memory) ;
    auto flags =  get_mem_region_flags(mem_reg->flags);
    MemRegion m(cell_name+"memregion"+std::to_string(i),mem_reg->phys_start,
                mem_reg->virt_start,
                mem_reg->size,
                flags);
    cell->add_memRegion(m);
  }
  free(mem_reg);
}

void  ReadDmp::add_jailhouse_pci_device()
{
  struct jailhouse_pci_device * pci;
  pci = (jailhouse_pci_device*) malloc(sizeof(jailhouse_pci_device));
  for(int i = 0; i < pci_count ; ++i)
  {
    memcpy(pci,p_buffer,sizeof(jailhouse_pci_device));
    p_buffer = (p_buffer) + sizeof(jailhouse_pci_device);
    std::vector<UNS_64> bar_mask(pci->bar_mask,
                            pci->bar_mask + 
                            ( sizeof(pci->bar_mask) /
                              sizeof((pci->bar_mask)[0])
                            ));
    PciDevice pci_device(cell_name+"pci_device"+std::to_string(i),
                       get_pci_type((__u8)(pci->type)),
                       (__u16)(pci->bdf),
                       bar_mask,
                       (__u32)(pci->shmem_region),
                       get_shemem_protocol((__u16)(pci->shmem_protocol))
                       );
    cell->add_pci(pci_device);
  }
  free(pci);
}

void  ReadDmp::add_jailhouse_irqchip()
{
  struct jailhouse_irqchip * irq_chip;
  irq_chip =(jailhouse_irqchip*) malloc(sizeof(jailhouse_irqchip));
  for(int i=0; i < irq_count ; ++i )
  {
    memcpy(irq_chip,p_buffer,sizeof(jailhouse_irqchip));
    p_buffer = (p_buffer) + sizeof(jailhouse_irqchip) ;
    std::vector<UNS_64> pin_bitmap(irq_chip->pin_bitmap, 
                               irq_chip->pin_bitmap + 
                               (sizeof(irq_chip->pin_bitmap) / 
                                sizeof ((irq_chip->pin_bitmap)[0])
                                      ));
    IrqChip irq(cell_name+"irqchip"+std::to_string(i),irq_chip->address,
                irq_chip->pin_base,
                pin_bitmap);
    
    cell->add_irqChip(irq);
  }
  free(irq_chip);
}

JailHouseCell * ReadDmp::get_cell()
{
  return cell;
}

ReadDmp::~ReadDmp()
{
  free(dmp_buffer);
}
